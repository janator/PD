# PD
PD-2020-DIHT 

Решения по курсу "Параллельные и распределенные вычисления", 3 курс, ФИВТ МФТИ, 2020г.

# Дз №1. Нахождение интеграла с использованием MPI

![equation](http://www.sciweavers.org/tex2img.php?eq=%5Cint%5Climits_0%5E1%5Cfrac%7B4%7D%7B1%2Bx%5E2%7Ddx&bc=White&fc=Black&im=jpg&fs=12&ff=arev&edit=)

### Постановка задачи: решить определенный интеграл методом трапеций.

Предполагается, что запуск исполняемого файла будет происходить с использованием p процессов. 
Один из p процессов («основной») разбивает отрезок [0; 1] на _N_ малых отрезков длиной ![equation](http://www.sciweavers.org/tex2img.php?eq=%5CDelta+x&bc=White&fc=Black&im=jpg&fs=12&ff=arev&edit=) (шаг интегрирования), 
и вычисляет с этим разбиением интеграл в последовательном варианте. Далее этот же процесс разбивает отрезок [0; 1], 
состоящий из _N_ малых отрезков, на _p_ частей и границы каждой из оставшихся _(p-1)_ частей рассылает остальным _(p-1)_ процессам 
(с одной из частей отрезка работает сам «основной» процесс). Число _N_ может меняться и задается пользователем.

Каждый из процессов, получивших свои границы части отрезка, должен вычислить свою часть интеграла _I<sub>i</sub>_ и отправить ее «основному» процессу.

«Основной» процесс получает все части интеграла от процессов-рабочих и, складывая их, получает исходный интеграл  _I_. 

### Задание:

1. Вывести на экран в столбик значения частей интеграла _I<sub>i</sub>_, посчитанные каждым из процессов-рабочих с указанием его номера.
2. Вывести на экран значение интеграла _I_, посчитанное сложением всех частей интеграла, полученных «основным» процессом от процессов-рабочих.
3. Вывести на экран интеграл _I<sub>0</sub>_, посчитанный «основным» процессом последовательно. Сравнить его со значением  _I_.
4. На одной координатной плоскости построить 3 графика зависимости ускорения _S_ от количества процессов _p_, где _p_ = 1,2,3, ... ,8 для _N_ = 1000, N = 10<sup>6</sup>  и для _N_ = 10<sup>8</sup>.

### Примечания:

1. Подумать над разбивкой отрезка [0; 1]  на части, когда _N_ не делится нацело на _p_.
2. Использовать следующую особенность программирования: если не обращаться ни к какому из процессов посредством конструкции if, а написать код в общей части, то этот кусок кода будет выполнен всеми процессами одинаково.
3. Если в общей части программы объявить переменную, то она в разных процессах будет называться одинаково, но может при этом принимать различные значения.

# ДЗ №2. Программирование на CUDA

# Уровень 3. Быстрая сортировка

На вход подается массив A, необходимо отсортировать его значения по возрастанию.

### Особенности реализации
1. Для реализации операции "получить значения элементов, значения которых меньше x" стоит использовать операцию сканирования.
2. На занятиях было разобрано, каким образом можно выполнить операцию сканирования на одном блоке, необходимо расширить эту конструкцию на весь массив.
3. Требованием константности дополнительной памяти можно пренебречь

### Дополнительная литература
* https://www.eecs.umich.edu/courses/eecs570/hw/parprefix.pdf - в целом про сканирование
* https://www.drdobbs.com/parallel/quicksort-partition-via-prefix-scan/240003109 - быстрая сортировка при помощи подсчета суммы на префиксе

# Домашнее задание по HDFS

## Задачи

#### 01 (0.1 балла)
На вход скрипту подается имя файла, на выходе нужно получить имя сервера или IP-адрес, с которого будет читаться первый блок данных (реплик может быть несколько, засчитываться будет любой из них). Пример:

	$ ./run.sh /data/access_logs/big_log/access.log.2015-12-10
	mipt-node01.atp-fivt.org

#### 02 (0.1 балла)
На вход скрипту подается имя файла, на выходе нужно получить первые 10 байт этого файла (hadoop fs и hdfs dfs использовать нельзя)

	$ ./run.sh /data/access_logs/big_log/access.log.2015-12-10
	41.190.60.

#### 03 (0.1 балла)
На вход скрипту подается полный путь до файла в HDFS, на выходе нужно получить размер файла в блоках (см. hdfs fsck -h).

	$ ./run.sh /data/access_logs/big_log/access.log.2015-12-10	
	8

#### 04 (0.3 балла)

На вход скрипту подается идентификатор блока, на выходе нужно получить имя сервера (если их несколько, то выбрать любой), где хранится данный блок и физический путь в локальной файловой системе до этого блока данных. (О том, как зайти на ноды кластера, написано в материалам [cеминара по HDFS](/distribute/practice/01-hdfs.md))

	$ ./run.sh blk_1075127191
	bds03.vdi.mipt.ru:/dfs/dn/current/BP-76251478-10.55.163.141-1427134131440/current/finalized/subdir21/subdir35/blk_1075127191
 
# Домашнее задание по Hadoop

## Задачи
 
1.(110) Список идентификаторов перемешайте в случайном порядке. Далее в каждой строке запишите через запятую случайное число идентификаторов - от 1 до 5.
Вариант способа перемешивания записей: дописать к каждой случайное число, отсортировать по нему весь список, потом число отбросить.
* Входные данные: список идентификаторов.
* Формат вывода: id1,id2,...
* Вывод на печать: первые 50 строк.

6.(116) (“Биграммы”) Найдите пары слов (биграмм), которые встречались в наибольшем числе документов. При разборе статей очищайте слова от от знаков пунктуации. Отсортируйте слова по числу документов, при равном числе - лексикографически.
* Входные данные: википедия.
* Формат вывода: слово#1 слово#2 <tab> число документов.
* Вывод на печать: топ10 биграмм

Пример вывода:
```
and the	3495
on the	3326
by the	3250
```

# Домашнее задание по Spark
## Задача 1

#### Исходные данные

* `/data/wiki/en_articles_part` - статьи Википедии. Засылать на тестирование нужно на частичном датасете (чтоб не перегружать кластер).

Формат данных:
```
article ID <tab> article text
```
* `/data/wiki/stop_words_en-xpo6.txt` - список стоп-слов для 2-й задачи.

Формат данных: одно стоп-слово на строчку
```
...
wherein
whereupon
wherever
...
```
#### Условие
Найдите все пары двух последовательных слов (биграмм), где первое слово «narodnaya». Для каждой пары подсчитайте количество вхождений в тексте статей Википедии. Выведите все пары с их частотой вхождений в лексикографическом порядке. Формат вывода - word_pair <tab> count.

**Пример результата**:
```
red_apple 100500
crazy_zoo 42
```
Обратите внимание, что два слова в паре объединяются с символом нижнего подчеркивания, а результат - в нижнем регистре.

#### Техническая информация
При парсинге отбрасывайте все символы, которые не являются латинскими буквами:
```
text = re.sub("^\W+|\W+$", "", text)
```
